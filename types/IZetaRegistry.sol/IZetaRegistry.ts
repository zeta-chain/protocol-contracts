/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  EventFragment,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedLogDescription,
  TypedListener,
  TypedContractMethod,
} from "../common";

export declare namespace IZetaRegistry {
  export type ChainInfoStruct = {
    chainId: BigNumberish;
    name: string;
    active: boolean;
    chainType: BigNumberish;
    blockConfirmations: BigNumberish;
  };

  export type ChainInfoStructOutput = [
    chainId: bigint,
    name: string,
    active: boolean,
    chainType: bigint,
    blockConfirmations: bigint
  ] & {
    chainId: bigint;
    name: string;
    active: boolean;
    chainType: bigint;
    blockConfirmations: bigint;
  };

  export type ContractInfoStruct = {
    active: boolean;
    addr: AddressLike;
    version: string;
    implementation: AddressLike;
    configurationData: BytesLike;
  };

  export type ContractInfoStructOutput = [
    active: boolean,
    addr: string,
    version: string,
    implementation: string,
    configurationData: string
  ] & {
    active: boolean;
    addr: string;
    version: string;
    implementation: string;
    configurationData: string;
  };
}

export interface IZetaRegistryInterface extends Interface {
  getFunction(
    nameOrSignature:
      | "addChain"
      | "addContract"
      | "addZRC20Token"
      | "batchAddContracts"
      | "chainExists"
      | "contractExists"
      | "createChainIdentifier"
      | "createContractIdentifier"
      | "getActiveChainIdentifiers"
      | "getAllChainIdentifiers"
      | "getChainCount"
      | "getChainInfo"
      | "getContractAddress"
      | "getContractIdentifiers"
      | "getContractIdentifiersByCategory"
      | "getContractInfo"
      | "getSystemAddresses"
      | "getZRC20Address"
      | "removeChain"
      | "removeContract"
      | "setChainActive"
      | "setContractActive"
      | "updateChain"
      | "updateContract"
      | "updateContractAddress"
      | "updateContractConfiguration"
  ): FunctionFragment;

  getEvent(
    nameOrSignatureOrTopic:
      | "ChainAdded"
      | "ChainStatusUpdated"
      | "ContractAddressUpdated"
      | "ContractConfigurationUpdated"
      | "ContractStatusUpdated"
      | "ZRC20TokenAdded"
  ): EventFragment;

  encodeFunctionData(
    functionFragment: "addChain",
    values: [BytesLike, IZetaRegistry.ChainInfoStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "addContract",
    values: [
      BytesLike,
      BytesLike,
      BigNumberish,
      IZetaRegistry.ContractInfoStruct
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "addZRC20Token",
    values: [BytesLike, BytesLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "batchAddContracts",
    values: [
      BytesLike,
      BytesLike[],
      BigNumberish[],
      IZetaRegistry.ContractInfoStruct[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "chainExists",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "contractExists",
    values: [BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "createChainIdentifier",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "createContractIdentifier",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "getActiveChainIdentifiers",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getAllChainIdentifiers",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getChainCount",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getChainInfo",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getContractAddress",
    values: [BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getContractIdentifiers",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getContractIdentifiersByCategory",
    values: [BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getContractInfo",
    values: [BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getSystemAddresses",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getZRC20Address",
    values: [BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "removeChain",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "removeContract",
    values: [BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "setChainActive",
    values: [BytesLike, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "setContractActive",
    values: [BytesLike, BytesLike, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "updateChain",
    values: [BytesLike, IZetaRegistry.ChainInfoStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "updateContract",
    values: [BytesLike, BytesLike, IZetaRegistry.ContractInfoStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "updateContractAddress",
    values: [BytesLike, BytesLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "updateContractConfiguration",
    values: [BytesLike, BytesLike, BytesLike]
  ): string;

  decodeFunctionResult(functionFragment: "addChain", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "addContract",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "addZRC20Token",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "batchAddContracts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "chainExists",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "contractExists",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createChainIdentifier",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createContractIdentifier",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getActiveChainIdentifiers",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getAllChainIdentifiers",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getChainCount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getChainInfo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getContractAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getContractIdentifiers",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getContractIdentifiersByCategory",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getContractInfo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getSystemAddresses",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getZRC20Address",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removeChain",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removeContract",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setChainActive",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setContractActive",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateChain",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateContract",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateContractAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateContractConfiguration",
    data: BytesLike
  ): Result;
}

export namespace ChainAddedEvent {
  export type InputTuple = [
    chainIdentifier: BytesLike,
    chainId: BigNumberish,
    name: string
  ];
  export type OutputTuple = [
    chainIdentifier: string,
    chainId: bigint,
    name: string
  ];
  export interface OutputObject {
    chainIdentifier: string;
    chainId: bigint;
    name: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ChainStatusUpdatedEvent {
  export type InputTuple = [chainIdentifier: BytesLike, active: boolean];
  export type OutputTuple = [chainIdentifier: string, active: boolean];
  export interface OutputObject {
    chainIdentifier: string;
    active: boolean;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ContractAddressUpdatedEvent {
  export type InputTuple = [
    chainIdentifier: BytesLike,
    contractIdentifier: BytesLike,
    category: BigNumberish,
    contractAddress: AddressLike
  ];
  export type OutputTuple = [
    chainIdentifier: string,
    contractIdentifier: string,
    category: bigint,
    contractAddress: string
  ];
  export interface OutputObject {
    chainIdentifier: string;
    contractIdentifier: string;
    category: bigint;
    contractAddress: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ContractConfigurationUpdatedEvent {
  export type InputTuple = [
    chainIdentifier: BytesLike,
    contractIdentifier: BytesLike,
    configurationData: BytesLike
  ];
  export type OutputTuple = [
    chainIdentifier: string,
    contractIdentifier: string,
    configurationData: string
  ];
  export interface OutputObject {
    chainIdentifier: string;
    contractIdentifier: string;
    configurationData: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ContractStatusUpdatedEvent {
  export type InputTuple = [
    chainIdentifier: BytesLike,
    contractIdentifier: BytesLike,
    active: boolean
  ];
  export type OutputTuple = [
    chainIdentifier: string,
    contractIdentifier: string,
    active: boolean
  ];
  export interface OutputObject {
    chainIdentifier: string;
    contractIdentifier: string;
    active: boolean;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ZRC20TokenAddedEvent {
  export type InputTuple = [
    chainIdentifier: BytesLike,
    tokenIdentifier: BytesLike,
    tokenAddress: AddressLike
  ];
  export type OutputTuple = [
    chainIdentifier: string,
    tokenIdentifier: string,
    tokenAddress: string
  ];
  export interface OutputObject {
    chainIdentifier: string;
    tokenIdentifier: string;
    tokenAddress: string;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export interface IZetaRegistry extends BaseContract {
  connect(runner?: ContractRunner | null): IZetaRegistry;
  waitForDeployment(): Promise<this>;

  interface: IZetaRegistryInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  addChain: TypedContractMethod<
    [chainIdentifier: BytesLike, chainInfo: IZetaRegistry.ChainInfoStruct],
    [boolean],
    "nonpayable"
  >;

  addContract: TypedContractMethod<
    [
      chainIdentifier: BytesLike,
      contractIdentifier: BytesLike,
      category: BigNumberish,
      contractInfo: IZetaRegistry.ContractInfoStruct
    ],
    [boolean],
    "nonpayable"
  >;

  addZRC20Token: TypedContractMethod<
    [
      chainIdentifier: BytesLike,
      tokenIdentifier: BytesLike,
      tokenAddress: AddressLike
    ],
    [boolean],
    "nonpayable"
  >;

  batchAddContracts: TypedContractMethod<
    [
      chainIdentifier: BytesLike,
      contractIdentifiers: BytesLike[],
      categories: BigNumberish[],
      contractInfos: IZetaRegistry.ContractInfoStruct[]
    ],
    [boolean],
    "nonpayable"
  >;

  chainExists: TypedContractMethod<
    [chainIdentifier: BytesLike],
    [boolean],
    "view"
  >;

  contractExists: TypedContractMethod<
    [chainIdentifier: BytesLike, contractIdentifier: BytesLike],
    [boolean],
    "view"
  >;

  createChainIdentifier: TypedContractMethod<[name: string], [string], "view">;

  createContractIdentifier: TypedContractMethod<
    [name: string],
    [string],
    "view"
  >;

  getActiveChainIdentifiers: TypedContractMethod<[], [string[]], "view">;

  getAllChainIdentifiers: TypedContractMethod<[], [string[]], "view">;

  getChainCount: TypedContractMethod<[], [bigint], "view">;

  getChainInfo: TypedContractMethod<
    [chainIdentifier: BytesLike],
    [IZetaRegistry.ChainInfoStructOutput],
    "view"
  >;

  getContractAddress: TypedContractMethod<
    [chainIdentifier: BytesLike, contractIdentifier: BytesLike],
    [string],
    "view"
  >;

  getContractIdentifiers: TypedContractMethod<
    [chainIdentifier: BytesLike],
    [string[]],
    "view"
  >;

  getContractIdentifiersByCategory: TypedContractMethod<
    [chainIdentifier: BytesLike, category: BigNumberish],
    [string[]],
    "view"
  >;

  getContractInfo: TypedContractMethod<
    [chainIdentifier: BytesLike, contractIdentifier: BytesLike],
    [IZetaRegistry.ContractInfoStructOutput],
    "view"
  >;

  getSystemAddresses: TypedContractMethod<
    [chainIdentifier: BytesLike],
    [
      [string, string, string, string, string] & {
        connector: string;
        erc20Custody: string;
        tss: string;
        tssUpdater: string;
        zetaToken: string;
      }
    ],
    "view"
  >;

  getZRC20Address: TypedContractMethod<
    [chainIdentifier: BytesLike, tokenIdentifier: BytesLike],
    [string],
    "view"
  >;

  removeChain: TypedContractMethod<
    [chainIdentifier: BytesLike],
    [boolean],
    "nonpayable"
  >;

  removeContract: TypedContractMethod<
    [chainIdentifier: BytesLike, contractIdentifier: BytesLike],
    [boolean],
    "nonpayable"
  >;

  setChainActive: TypedContractMethod<
    [chainIdentifier: BytesLike, active: boolean],
    [boolean],
    "nonpayable"
  >;

  setContractActive: TypedContractMethod<
    [
      chainIdentifier: BytesLike,
      contractIdentifier: BytesLike,
      active: boolean
    ],
    [boolean],
    "nonpayable"
  >;

  updateChain: TypedContractMethod<
    [chainIdentifier: BytesLike, chainInfo: IZetaRegistry.ChainInfoStruct],
    [boolean],
    "nonpayable"
  >;

  updateContract: TypedContractMethod<
    [
      chainIdentifier: BytesLike,
      contractIdentifier: BytesLike,
      contractInfo: IZetaRegistry.ContractInfoStruct
    ],
    [boolean],
    "nonpayable"
  >;

  updateContractAddress: TypedContractMethod<
    [
      chainIdentifier: BytesLike,
      contractIdentifier: BytesLike,
      newAddress: AddressLike
    ],
    [boolean],
    "nonpayable"
  >;

  updateContractConfiguration: TypedContractMethod<
    [
      chainIdentifier: BytesLike,
      contractIdentifier: BytesLike,
      configurationData: BytesLike
    ],
    [boolean],
    "nonpayable"
  >;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "addChain"
  ): TypedContractMethod<
    [chainIdentifier: BytesLike, chainInfo: IZetaRegistry.ChainInfoStruct],
    [boolean],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "addContract"
  ): TypedContractMethod<
    [
      chainIdentifier: BytesLike,
      contractIdentifier: BytesLike,
      category: BigNumberish,
      contractInfo: IZetaRegistry.ContractInfoStruct
    ],
    [boolean],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "addZRC20Token"
  ): TypedContractMethod<
    [
      chainIdentifier: BytesLike,
      tokenIdentifier: BytesLike,
      tokenAddress: AddressLike
    ],
    [boolean],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "batchAddContracts"
  ): TypedContractMethod<
    [
      chainIdentifier: BytesLike,
      contractIdentifiers: BytesLike[],
      categories: BigNumberish[],
      contractInfos: IZetaRegistry.ContractInfoStruct[]
    ],
    [boolean],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "chainExists"
  ): TypedContractMethod<[chainIdentifier: BytesLike], [boolean], "view">;
  getFunction(
    nameOrSignature: "contractExists"
  ): TypedContractMethod<
    [chainIdentifier: BytesLike, contractIdentifier: BytesLike],
    [boolean],
    "view"
  >;
  getFunction(
    nameOrSignature: "createChainIdentifier"
  ): TypedContractMethod<[name: string], [string], "view">;
  getFunction(
    nameOrSignature: "createContractIdentifier"
  ): TypedContractMethod<[name: string], [string], "view">;
  getFunction(
    nameOrSignature: "getActiveChainIdentifiers"
  ): TypedContractMethod<[], [string[]], "view">;
  getFunction(
    nameOrSignature: "getAllChainIdentifiers"
  ): TypedContractMethod<[], [string[]], "view">;
  getFunction(
    nameOrSignature: "getChainCount"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "getChainInfo"
  ): TypedContractMethod<
    [chainIdentifier: BytesLike],
    [IZetaRegistry.ChainInfoStructOutput],
    "view"
  >;
  getFunction(
    nameOrSignature: "getContractAddress"
  ): TypedContractMethod<
    [chainIdentifier: BytesLike, contractIdentifier: BytesLike],
    [string],
    "view"
  >;
  getFunction(
    nameOrSignature: "getContractIdentifiers"
  ): TypedContractMethod<[chainIdentifier: BytesLike], [string[]], "view">;
  getFunction(
    nameOrSignature: "getContractIdentifiersByCategory"
  ): TypedContractMethod<
    [chainIdentifier: BytesLike, category: BigNumberish],
    [string[]],
    "view"
  >;
  getFunction(
    nameOrSignature: "getContractInfo"
  ): TypedContractMethod<
    [chainIdentifier: BytesLike, contractIdentifier: BytesLike],
    [IZetaRegistry.ContractInfoStructOutput],
    "view"
  >;
  getFunction(
    nameOrSignature: "getSystemAddresses"
  ): TypedContractMethod<
    [chainIdentifier: BytesLike],
    [
      [string, string, string, string, string] & {
        connector: string;
        erc20Custody: string;
        tss: string;
        tssUpdater: string;
        zetaToken: string;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "getZRC20Address"
  ): TypedContractMethod<
    [chainIdentifier: BytesLike, tokenIdentifier: BytesLike],
    [string],
    "view"
  >;
  getFunction(
    nameOrSignature: "removeChain"
  ): TypedContractMethod<[chainIdentifier: BytesLike], [boolean], "nonpayable">;
  getFunction(
    nameOrSignature: "removeContract"
  ): TypedContractMethod<
    [chainIdentifier: BytesLike, contractIdentifier: BytesLike],
    [boolean],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setChainActive"
  ): TypedContractMethod<
    [chainIdentifier: BytesLike, active: boolean],
    [boolean],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setContractActive"
  ): TypedContractMethod<
    [
      chainIdentifier: BytesLike,
      contractIdentifier: BytesLike,
      active: boolean
    ],
    [boolean],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "updateChain"
  ): TypedContractMethod<
    [chainIdentifier: BytesLike, chainInfo: IZetaRegistry.ChainInfoStruct],
    [boolean],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "updateContract"
  ): TypedContractMethod<
    [
      chainIdentifier: BytesLike,
      contractIdentifier: BytesLike,
      contractInfo: IZetaRegistry.ContractInfoStruct
    ],
    [boolean],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "updateContractAddress"
  ): TypedContractMethod<
    [
      chainIdentifier: BytesLike,
      contractIdentifier: BytesLike,
      newAddress: AddressLike
    ],
    [boolean],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "updateContractConfiguration"
  ): TypedContractMethod<
    [
      chainIdentifier: BytesLike,
      contractIdentifier: BytesLike,
      configurationData: BytesLike
    ],
    [boolean],
    "nonpayable"
  >;

  getEvent(
    key: "ChainAdded"
  ): TypedContractEvent<
    ChainAddedEvent.InputTuple,
    ChainAddedEvent.OutputTuple,
    ChainAddedEvent.OutputObject
  >;
  getEvent(
    key: "ChainStatusUpdated"
  ): TypedContractEvent<
    ChainStatusUpdatedEvent.InputTuple,
    ChainStatusUpdatedEvent.OutputTuple,
    ChainStatusUpdatedEvent.OutputObject
  >;
  getEvent(
    key: "ContractAddressUpdated"
  ): TypedContractEvent<
    ContractAddressUpdatedEvent.InputTuple,
    ContractAddressUpdatedEvent.OutputTuple,
    ContractAddressUpdatedEvent.OutputObject
  >;
  getEvent(
    key: "ContractConfigurationUpdated"
  ): TypedContractEvent<
    ContractConfigurationUpdatedEvent.InputTuple,
    ContractConfigurationUpdatedEvent.OutputTuple,
    ContractConfigurationUpdatedEvent.OutputObject
  >;
  getEvent(
    key: "ContractStatusUpdated"
  ): TypedContractEvent<
    ContractStatusUpdatedEvent.InputTuple,
    ContractStatusUpdatedEvent.OutputTuple,
    ContractStatusUpdatedEvent.OutputObject
  >;
  getEvent(
    key: "ZRC20TokenAdded"
  ): TypedContractEvent<
    ZRC20TokenAddedEvent.InputTuple,
    ZRC20TokenAddedEvent.OutputTuple,
    ZRC20TokenAddedEvent.OutputObject
  >;

  filters: {
    "ChainAdded(bytes32,uint256,string)": TypedContractEvent<
      ChainAddedEvent.InputTuple,
      ChainAddedEvent.OutputTuple,
      ChainAddedEvent.OutputObject
    >;
    ChainAdded: TypedContractEvent<
      ChainAddedEvent.InputTuple,
      ChainAddedEvent.OutputTuple,
      ChainAddedEvent.OutputObject
    >;

    "ChainStatusUpdated(bytes32,bool)": TypedContractEvent<
      ChainStatusUpdatedEvent.InputTuple,
      ChainStatusUpdatedEvent.OutputTuple,
      ChainStatusUpdatedEvent.OutputObject
    >;
    ChainStatusUpdated: TypedContractEvent<
      ChainStatusUpdatedEvent.InputTuple,
      ChainStatusUpdatedEvent.OutputTuple,
      ChainStatusUpdatedEvent.OutputObject
    >;

    "ContractAddressUpdated(bytes32,bytes32,uint8,address)": TypedContractEvent<
      ContractAddressUpdatedEvent.InputTuple,
      ContractAddressUpdatedEvent.OutputTuple,
      ContractAddressUpdatedEvent.OutputObject
    >;
    ContractAddressUpdated: TypedContractEvent<
      ContractAddressUpdatedEvent.InputTuple,
      ContractAddressUpdatedEvent.OutputTuple,
      ContractAddressUpdatedEvent.OutputObject
    >;

    "ContractConfigurationUpdated(bytes32,bytes32,bytes)": TypedContractEvent<
      ContractConfigurationUpdatedEvent.InputTuple,
      ContractConfigurationUpdatedEvent.OutputTuple,
      ContractConfigurationUpdatedEvent.OutputObject
    >;
    ContractConfigurationUpdated: TypedContractEvent<
      ContractConfigurationUpdatedEvent.InputTuple,
      ContractConfigurationUpdatedEvent.OutputTuple,
      ContractConfigurationUpdatedEvent.OutputObject
    >;

    "ContractStatusUpdated(bytes32,bytes32,bool)": TypedContractEvent<
      ContractStatusUpdatedEvent.InputTuple,
      ContractStatusUpdatedEvent.OutputTuple,
      ContractStatusUpdatedEvent.OutputObject
    >;
    ContractStatusUpdated: TypedContractEvent<
      ContractStatusUpdatedEvent.InputTuple,
      ContractStatusUpdatedEvent.OutputTuple,
      ContractStatusUpdatedEvent.OutputObject
    >;

    "ZRC20TokenAdded(bytes32,bytes32,address)": TypedContractEvent<
      ZRC20TokenAddedEvent.InputTuple,
      ZRC20TokenAddedEvent.OutputTuple,
      ZRC20TokenAddedEvent.OutputObject
    >;
    ZRC20TokenAdded: TypedContractEvent<
      ZRC20TokenAddedEvent.InputTuple,
      ZRC20TokenAddedEvent.OutputTuple,
      ZRC20TokenAddedEvent.OutputObject
    >;
  };
}
